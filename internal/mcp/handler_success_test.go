package mcp

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/acolita/claude-shell-mcp/internal/config"
	"github.com/acolita/claude-shell-mcp/internal/session"
	"github.com/acolita/claude-shell-mcp/internal/testing/fakes/fakeclock"
	"github.com/acolita/claude-shell-mcp/internal/testing/fakes/fakefs"
	"github.com/acolita/claude-shell-mcp/internal/testing/fakes/fakepty"
	"github.com/acolita/claude-shell-mcp/internal/testing/fakes/fakerand"
	"github.com/acolita/claude-shell-mcp/internal/testing/fakes/fakesessionmgr"
)

// newFakeSessionWithRand creates a session with a predictable random source
// so we can predict the command ID generated by Exec.
func newFakeSessionWithRand(id string) (*session.Session, *fakepty.PTY) {
	pty := fakepty.New()
	clk := fakeclock.New(time.Now())
	rnd := fakerand.NewSequential()
	sess := session.NewSession(id, "local",
		session.WithPTY(pty),
		session.WithSessionClock(clk),
		session.WithSessionRandom(rnd),
	)
	return sess, pty
}

// newFakeSessionWithClock creates a session with a clock (needed for Status() calls).
func newFakeSessionWithClock(id string) *session.Session {
	pty := fakepty.New()
	clk := fakeclock.New(time.Now())
	return session.NewSession(id, "local",
		session.WithPTY(pty),
		session.WithSessionClock(clk),
	)
}

// ==================== handleShellExec success paths ====================

func TestHandleShellExec_SuccessPath(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_exec")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// With sequential fakerand, generateCommandID produces hex of bytes [0,1,2,3] = "00010203"
	cmdID := "00010203"
	startMarker := "___CMD_START_" + cmdID + "___"
	endMarker := "___CMD_END_" + cmdID + "___"

	// Queue the PTY response that Exec will read.
	pty.AddResponse(startMarker + "\n" + "file1.txt\nfile2.txt\n" + endMarker + "0\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_exec",
		"command":    "ls",
	})

	result, err := srv.handleShellExec(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
	exitCode, ok := m["exit_code"].(float64)
	if !ok || exitCode != 0 {
		t.Errorf("exit_code = %v, want 0", m["exit_code"])
	}
	if m["command_id"] != cmdID {
		t.Errorf("command_id = %v, want %s", m["command_id"], cmdID)
	}
	stdout, _ := m["stdout"].(string)
	if !strings.Contains(stdout, "file1.txt") {
		t.Errorf("stdout should contain file1.txt, got: %s", stdout)
	}
}

func TestHandleShellExec_WithTailLines(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_tail")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	cmdID := "00010203"
	startMarker := "___CMD_START_" + cmdID + "___"
	endMarker := "___CMD_END_" + cmdID + "___"

	outputLines := "line1\nline2\nline3\nline4\nline5\nline6\nline7\nline8\nline9\nline10"
	pty.AddResponse(startMarker + "\n" + outputLines + "\n" + endMarker + "0\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_tail",
		"command":    "seq 1 10",
		"tail_lines": float64(3),
	})

	result, err := srv.handleShellExec(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
	if m["truncated"] != true {
		t.Errorf("truncated = %v, want true", m["truncated"])
	}
	stdout, _ := m["stdout"].(string)
	if !strings.Contains(stdout, "line10") {
		t.Errorf("stdout should contain line10 (tail), got: %s", stdout)
	}
}

func TestHandleShellExec_WithHeadLines(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_head")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	cmdID := "00010203"
	startMarker := "___CMD_START_" + cmdID + "___"
	endMarker := "___CMD_END_" + cmdID + "___"

	outputLines := "line1\nline2\nline3\nline4\nline5\nline6\nline7\nline8\nline9\nline10"
	pty.AddResponse(startMarker + "\n" + outputLines + "\n" + endMarker + "0\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_head",
		"command":    "seq 1 10",
		"head_lines": float64(2),
	})

	result, err := srv.handleShellExec(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
	if m["truncated"] != true {
		t.Errorf("truncated = %v, want true", m["truncated"])
	}
	stdout, _ := m["stdout"].(string)
	if !strings.Contains(stdout, "line1") {
		t.Errorf("stdout should contain line1 (head), got: %s", stdout)
	}
	if strings.Contains(stdout, "line10") {
		t.Errorf("stdout should not contain line10 with head_lines=2, got: %s", stdout)
	}
}

func TestHandleShellExec_CommandBlockedByFilter(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSession("sess_blocked2")
	sm.AddSession(sess)

	cfg := config.DefaultConfig()
	cfg.Security.CommandBlocklist = []string{`^rm\s`}
	fs := fakefs.New()
	srv := NewServer(cfg,
		WithSessionManager(sm),
		WithFileSystem(fs),
		WithClock(fakeclock.New(time.Now())),
	)

	req := makeRequest(map[string]any{
		"session_id": "sess_blocked2",
		"command":    "rm -rf /tmp/stuff",
	})

	result, err := srv.handleShellExec(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !result.IsError {
		t.Error("expected error for blocked command")
	}
	text := resultText(result)
	if !strings.Contains(text, "command blocked") {
		t.Errorf("error should mention 'command blocked', got: %s", text)
	}
}

func TestHandleShellExec_NonZeroExitCode(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_exitcode")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	cmdID := "00010203"
	startMarker := "___CMD_START_" + cmdID + "___"
	endMarker := "___CMD_END_" + cmdID + "___"

	pty.AddResponse(startMarker + "\ncommand not found\n" + endMarker + "127\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_exitcode",
		"command":    "nonexistent_cmd",
	})

	result, err := srv.handleShellExec(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
	exitCode, ok := m["exit_code"].(float64)
	if !ok || exitCode != 127 {
		t.Errorf("exit_code = %v, want 127", m["exit_code"])
	}
}

// ==================== handleShellProvideInput success paths ====================

func TestHandleShellProvideInput_SuccessPath(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_input")
	sess.State = session.StateAwaitingInput
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// ProvideInput uses readOutput (legacy path), which looks for legacy end marker
	pty.AddResponse("command output here\n___CMD_END_MARKER___0\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_input",
		"input":      "yes",
	})

	result, err := srv.handleShellProvideInput(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
}

func TestHandleShellProvideInput_WithCacheForSudo(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_sudo_cache")
	sess.State = session.StateAwaitingInput
	sm.AddSession(sess)
	srv := newTestServer(sm)

	pty.AddResponse("command completed\n___CMD_END_MARKER___0\n")

	req := makeRequest(map[string]any{
		"session_id":     "sess_sudo_cache",
		"input":          "mypassword",
		"cache_for_sudo": true,
	})

	result, err := srv.handleShellProvideInput(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
	if m["sudo_authenticated"] != true {
		t.Errorf("sudo_authenticated = %v, want true", m["sudo_authenticated"])
	}
	expiresIn, ok := m["sudo_expires_in_seconds"].(float64)
	if !ok || expiresIn <= 0 {
		t.Errorf("sudo_expires_in_seconds = %v, want positive value", m["sudo_expires_in_seconds"])
	}
}

// ==================== handleShellSudoAuth success paths ====================

func TestHandleShellSudoAuth_WithConfiguredPassword(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_sudoauth")
	sess.State = session.StateAwaitingInput
	sess.Host = "prod.example.com"
	sm.AddSession(sess)

	cfg := &config.Config{
		Servers: []config.ServerConfig{
			{Name: "prod", Host: "prod.example.com", SudoPasswordEnv: "SUDO_PASS"},
		},
	}
	fs := fakefs.New()
	fs.SetEnv("SUDO_PASS", "secret123")
	srv := NewServer(cfg,
		WithSessionManager(sm),
		WithFileSystem(fs),
		WithClock(fakeclock.New(time.Now())),
	)

	// ProvideInput (called by handleShellSudoAuth) reads from PTY
	pty.AddResponse("auth success\n___CMD_END_MARKER___0\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_sudoauth",
	})

	result, err := srv.handleShellSudoAuth(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
	if m["sudo_authenticated"] != true {
		t.Errorf("sudo_authenticated = %v, want true", m["sudo_authenticated"])
	}
}

func TestHandleShellSudoAuth_NoPasswordForHost(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSession("sess_nopass")
	sess.Host = "unknown.example.com"
	sm.AddSession(sess)

	// Config has no matching server for this host
	cfg := &config.Config{
		Servers: []config.ServerConfig{
			{Name: "prod", Host: "prod.example.com", SudoPasswordEnv: "SUDO_PASS"},
		},
	}
	fs := fakefs.New()
	srv := NewServer(cfg,
		WithSessionManager(sm),
		WithFileSystem(fs),
		WithClock(fakeclock.New(time.Now())),
	)

	req := makeRequest(map[string]any{
		"session_id": "sess_nopass",
	})

	result, err := srv.handleShellSudoAuth(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !result.IsError {
		t.Error("expected error when no password configured for host")
	}
	text := resultText(result)
	if !strings.Contains(text, "No sudo password configured") {
		t.Errorf("error should mention no password configured, got: %s", text)
	}
}

// ==================== handleShellSendRaw success paths ====================

func TestHandleShellSendRaw_SuccessPath(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_raw")
	sess.State = session.StateAwaitingInput
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// SendRaw uses readOutput (legacy path)
	pty.AddResponse("raw output\n___CMD_END_MARKER___0\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_raw",
		"input":      "\\x04", // EOF
	})

	result, err := srv.handleShellSendRaw(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["status"] != "completed" {
		t.Errorf("status = %v, want completed", m["status"])
	}
}

func TestHandleShellSendRaw_EmptyInputRejected(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSession("sess_raw_empty")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	req := makeRequest(map[string]any{
		"session_id": "sess_raw_empty",
		"input":      "",
	})

	result, err := srv.handleShellSendRaw(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !result.IsError {
		t.Error("expected error for empty input")
	}
	text := resultText(result)
	if !strings.Contains(text, "input is required") {
		t.Errorf("error should mention input required, got: %s", text)
	}
}

// ==================== handleShellInterrupt success paths ====================

func TestHandleShellInterrupt_SuccessFromRunning(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSessionWithClock("sess_int_run")
	sess.State = session.StateRunning
	sm.AddSession(sess)
	srv := newTestServer(sm)

	req := makeRequest(map[string]any{
		"session_id": "sess_int_run",
	})

	result, err := srv.handleShellInterrupt(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	text := resultText(result)
	if !strings.Contains(text, "Interrupt signal sent") {
		t.Errorf("result should say interrupt sent, got: %s", text)
	}
}

func TestHandleShellInterrupt_SuccessFromAwaitingInput(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSessionWithClock("sess_int_await")
	sess.State = session.StateAwaitingInput
	sm.AddSession(sess)
	srv := newTestServer(sm)

	req := makeRequest(map[string]any{
		"session_id": "sess_int_await",
	})

	result, err := srv.handleShellInterrupt(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	text := resultText(result)
	if !strings.Contains(text, "Interrupt signal sent") {
		t.Errorf("result should say interrupt sent, got: %s", text)
	}
}

// ==================== handleShellSessionStatus success paths ====================

func TestHandleShellSessionStatus_SuccessPath(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_st")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// CaptureEnv and CaptureAliases will write commands and read from PTY
	pty.AddResponse("HOME=/home/test\nPATH=/usr/bin\n")
	pty.AddResponse("alias ll='ls -la'\n")

	req := makeRequest(map[string]any{
		"session_id": "sess_st",
	})

	result, err := srv.handleShellSessionStatus(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["state"] != "idle" {
		t.Errorf("state = %v, want idle", m["state"])
	}
	if m["mode"] != "local" {
		t.Errorf("mode = %v, want local", m["mode"])
	}
	sessionID, _ := m["session_id"].(string)
	if sessionID != "sess_st" {
		t.Errorf("session_id = %v, want sess_st", sessionID)
	}
}

func TestHandleShellSessionStatus_WithSudoCache(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_statcache")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// Set sudo cache for this session
	srv.sudoCache.Set("sess_statcache", []byte("cached_pw"))

	// Queue responses for env and alias commands
	pty.AddResponse("HOME=/home/test\n")
	pty.AddResponse("")

	req := makeRequest(map[string]any{
		"session_id": "sess_statcache",
	})

	result, err := srv.handleShellSessionStatus(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["sudo_cached"] != true {
		t.Errorf("sudo_cached = %v, want true", m["sudo_cached"])
	}
	expiresIn, ok := m["sudo_expires_in_seconds"].(float64)
	if !ok || expiresIn <= 0 {
		t.Errorf("sudo_expires_in_seconds = %v, want positive value", m["sudo_expires_in_seconds"])
	}
}

// ==================== handleShellDebug success paths ====================

func TestHandleShellDebug_DefaultActionIsStatus(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSessionWithClock("sess_dbg_default")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// No action specified, defaults to "status"
	req := makeRequest(map[string]any{
		"session_id": "sess_dbg_default",
	})

	result, err := srv.handleShellDebug(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["action"] != "status" {
		t.Errorf("action = %v, want status (default)", m["action"])
	}
	if m["session_id"] != "sess_dbg_default" {
		t.Errorf("session_id = %v, want sess_dbg_default", m["session_id"])
	}
	if m["mode"] != "local" {
		t.Errorf("mode = %v, want local", m["mode"])
	}
	if m["state"] != "idle" {
		t.Errorf("state = %v, want idle", m["state"])
	}
}

func TestHandleShellDebug_ForegroundActionLocal(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSessionWithClock("sess_dbg_fg2")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	req := makeRequest(map[string]any{
		"session_id": "sess_dbg_fg2",
		"action":     "foreground",
	})

	result, err := srv.handleShellDebug(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.IsError {
		t.Fatalf("unexpected error result: %s", resultText(result))
	}

	m := resultJSON(t, result)
	if m["action"] != "foreground" {
		t.Errorf("action = %v, want foreground", m["action"])
	}
	// Control plane should not be available for a basic fake session
	if m["control_plane_available"] != false {
		t.Errorf("control_plane_available = %v, want false", m["control_plane_available"])
	}
}

func TestHandleShellDebug_ControlExecMissingCommand(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSessionWithClock("sess_dbg_ce2")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	req := makeRequest(map[string]any{
		"session_id": "sess_dbg_ce2",
		"action":     "control_exec",
	})

	result, err := srv.handleShellDebug(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !result.IsError {
		t.Error("expected error for control_exec without command")
	}
	text := resultText(result)
	if !strings.Contains(text, "command is required") {
		t.Errorf("error should mention command required, got: %s", text)
	}
}

func TestHandleShellDebug_ControlExecNoControlSession(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSessionWithClock("sess_dbg_nocs2")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	req := makeRequest(map[string]any{
		"session_id": "sess_dbg_nocs2",
		"action":     "control_exec",
		"command":    "ps aux",
	})

	result, err := srv.handleShellDebug(context.Background(), req)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if !result.IsError {
		t.Error("expected error for control_exec without control session")
	}
	text := resultText(result)
	if !strings.Contains(text, "control session not available") {
		t.Errorf("error should mention control session not available, got: %s", text)
	}
}

// ==================== tryCachedSudoInjection success paths ====================

func TestTryCachedSudoInjection_WithCachedPassword(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_inject")
	sess.State = session.StateAwaitingInput
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// Pre-cache a sudo password for this session
	srv.sudoCache.Set("sess_inject", []byte("cachedpw"))

	// Queue response for ProvideInput which injects the cached password
	pty.AddResponse("sudo output\n___CMD_END_MARKER___0\n")

	// Create an exec result that looks like a password prompt was detected
	inputResult := &session.ExecResult{
		Status:     "awaiting_input",
		PromptType: "password",
		PromptText: "[sudo] password for user:",
		MaskInput:  true,
	}

	newResult, err := srv.tryCachedSudoInjection("sess_inject", sess, inputResult)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if newResult.Status != "completed" {
		t.Errorf("status = %v, want completed", newResult.Status)
	}
	if !newResult.SudoAuthenticated {
		t.Error("expected sudo_authenticated to be true")
	}
}

func TestTryCachedSudoInjection_WithConfigPassword(t *testing.T) {
	sm := fakesessionmgr.New()
	sess, pty := newFakeSessionWithRand("sess_inject_cfg")
	sess.State = session.StateAwaitingInput
	sess.Host = "myserver.example.com"
	sm.AddSession(sess)

	cfg := &config.Config{
		Servers: []config.ServerConfig{
			{Name: "myserver", Host: "myserver.example.com", SudoPasswordEnv: "MY_SUDO_PW"},
		},
	}
	fs := fakefs.New()
	fs.SetEnv("MY_SUDO_PW", "envpassword")
	srv := NewServer(cfg,
		WithSessionManager(sm),
		WithFileSystem(fs),
		WithClock(fakeclock.New(time.Now())),
	)

	// Queue response for ProvideInput
	pty.AddResponse("sudo output from config\n___CMD_END_MARKER___0\n")

	inputResult := &session.ExecResult{
		Status:     "awaiting_input",
		PromptType: "password",
		PromptText: "[sudo] password for user:",
		MaskInput:  true,
	}

	newResult, err := srv.tryCachedSudoInjection("sess_inject_cfg", sess, inputResult)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if newResult.Status != "completed" {
		t.Errorf("status = %v, want completed", newResult.Status)
	}
	if !newResult.SudoAuthenticated {
		t.Error("expected sudo_authenticated to be true")
	}
}

func TestTryCachedSudoInjection_NonPasswordPromptPassthrough(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSession("sess_inject_nonpw")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// Non-password prompt should be passed through unchanged
	inputResult := &session.ExecResult{
		Status:     "awaiting_input",
		PromptType: "confirmation",
		PromptText: "Do you want to continue? [Y/n]",
	}

	newResult, err := srv.tryCachedSudoInjection("sess_inject_nonpw", sess, inputResult)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if newResult != inputResult {
		t.Error("expected same result object for non-password prompt (passthrough)")
	}
	if newResult.Status != "awaiting_input" {
		t.Errorf("status = %v, want awaiting_input", newResult.Status)
	}
	if newResult.PromptType != "confirmation" {
		t.Errorf("prompt_type = %v, want confirmation", newResult.PromptType)
	}
}

func TestTryCachedSudoInjection_CompletedStatusPassthrough(t *testing.T) {
	sm := fakesessionmgr.New()
	sess := newFakeSession("sess_inject_done")
	sm.AddSession(sess)
	srv := newTestServer(sm)

	// Already completed - should pass through
	exitCode := 0
	inputResult := &session.ExecResult{
		Status:   "completed",
		ExitCode: &exitCode,
		Stdout:   "all done",
	}

	newResult, err := srv.tryCachedSudoInjection("sess_inject_done", sess, inputResult)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if newResult != inputResult {
		t.Error("expected same result object for completed status (passthrough)")
	}
}

// ==================== validateSSHParams with rate limiting ====================

func TestValidateSSHParams_RateLimitTriggered(t *testing.T) {
	sm := fakesessionmgr.New()
	srv := newTestServer(sm)

	// Record enough failures to trigger lockout (default max = 5)
	for i := 0; i < 10; i++ {
		srv.authRateLimiter.RecordFailure("locked-host", "locked-user")
	}

	result := srv.validateSSHParams("locked-host", "locked-user")
	if result == nil {
		t.Fatal("expected error result for rate-limited host/user")
	}
	if !result.IsError {
		t.Error("expected IsError to be true")
	}
	text := resultText(result)
	if !strings.Contains(text, "authentication locked") {
		t.Errorf("error should mention authentication locked, got: %s", text)
	}
}
